<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> qiskit安装与使用 · Hexo</title><meta name="description" content="qiskit安装与使用 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://example.com/atom.xml" title="Hexo"><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/miller-star" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">qiskit安装与使用</h1><div class="post-info">Mar 6, 2024</div><div class="post-content"><h2 id="1-基本信息介绍"><a href="#1-基本信息介绍" class="headerlink" title="1. 基本信息介绍"></a>1. 基本信息介绍</h2><p>Qiskit是IBM开发的量子计算软件库。它由四个主要组件构成：Terra（提供了与量子硬件的底层接口，以及编译和优化量子电路的工具），Aer（提供了高性能的量子模拟器），Ignis（提供了量子错误校正和量子噪声分析的工具），以及Aqua（提供了一系列预构建的量子算法，如量子机器学习、量子优化和量子化学）。Qiskit的一个显著特点是其<strong>对物理硬件的直接支持</strong>，用户可以直接在IBM的量子计算机上运行他们的程序，或者使用Qiskit Aer在本地模拟。</p>
<h2 id="2-支持的平台"><a href="#2-支持的平台" class="headerlink" title="2. 支持的平台"></a>2. 支持的平台</h2><ul>
<li><p>IBM Quantum Experience（IBM的量子云平台）</p>
</li>
<li><p>Azure Quantum （微软的量子云平台）</p>
</li>
<li><p>其他第三方硬件：Qiskit还可以在许多第三方提供的硬件上运行，包括超导量子位和离子阱等</p>
<blockquote>
<p>它遵循<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%87%8F%E5%AD%90%E5%9C%96%E9%9D%88%E6%A9%9F">通用量子计算</a>的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%87%8F%E5%AD%90%E7%B7%9A%E8%B7%AF">电路模式</a>，可用于遵循该模式的<strong>任何</strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%87%8F%E5%AD%90%E4%BD%8D%E5%85%83">量子硬件</a>上（目前支持<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%B6%85%E5%B0%8E%E9%87%8F%E5%AD%90%E8%A8%88%E7%AE%97&action=edit&redlink=1">超导量子位</a>及离子阱[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/Qiskit#cite_note-5">维基百科]</a></p>
</blockquote>
</li>
<li><p>本地模拟器</p>
<blockquote>
<p>Qiskit还提供了一些模拟器，如<code>statevector</code>、<code>density_matrix</code>和<code>unitary</code>模拟器，这些模拟器可以在NVidia GPUs上运行。这意味着你可以在本地的GPU上模拟你的Qiskit代码，而不需要连接到任何的量子硬件—维基百科</p>
</blockquote>
</li>
</ul>
<h2 id="3-支持的开发语言"><a href="#3-支持的开发语言" class="headerlink" title="3. 支持的开发语言"></a>3. 支持的开发语言</h2><p>目前仅支持python</p>
<h2 id="4-安装"><a href="#4-安装" class="headerlink" title="4. 安装"></a>4. 安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install qiskit</span><br><span class="line">pip install qiskit-ibm-runtime</span><br></pre></td></tr></table></figure>

<h2 id="5-创建service与backend"><a href="#5-创建service与backend" class="headerlink" title="5. 创建service与backend"></a>5. 创建service与backend</h2><p>首先查看后端类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Initialize your account</span></span><br><span class="line"><span class="keyword">from</span> qiskit_ibm_runtime <span class="keyword">import</span> QiskitRuntimeService</span><br><span class="line">service = QiskitRuntimeService()</span><br><span class="line">service.backends()</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[&lt;IBMBackend(&#x27;ibmq_qasm_simulator&#x27;)&gt;,</span><br><span class="line"> &lt;IBMBackend(&#x27;ibmq_mumbai&#x27;)&gt;,</span><br><span class="line"> &lt;IBMBackend(&#x27;ibm_hanoi&#x27;)&gt;,</span><br><span class="line"> &lt;IBMBackend(&#x27;ibm_osaka&#x27;)&gt;,</span><br><span class="line"> &lt;IBMBackend(&#x27;ibm_cusco&#x27;)&gt;,</span><br><span class="line"> &lt;IBMBackend(&#x27;ibm_sherbrooke&#x27;)&gt;,</span><br><span class="line"> &lt;IBMBackend(&#x27;ibm_nazca&#x27;)&gt;,</span><br><span class="line"> &lt;IBMBackend(&#x27;ibm_kyoto&#x27;)&gt;,</span><br><span class="line"> &lt;IBMBackend(&#x27;ibm_cairo&#x27;)&gt;,</span><br><span class="line"> &lt;IBMBackend(&#x27;ibmq_kolkata&#x27;)&gt;,</span><br><span class="line"> &lt;IBMBackend(&#x27;ibm_brisbane&#x27;)&gt;,</span><br><span class="line"> &lt;IBMBackend(&#x27;ibm_algiers&#x27;)&gt;,</span><br><span class="line"> &lt;IBMBackend(&#x27;ibm_torino&#x27;)&gt;]</span><br></pre></td></tr></table></figure>

<p>根据后端类型，创建一个service</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service.backend(<span class="string">&quot;ibmq_qasm_simulator&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="设置IBM-Quantum-Channel"><a href="#设置IBM-Quantum-Channel" class="headerlink" title="设置IBM Quantum Channel"></a>设置IBM Quantum Channel</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit_ibm_runtime <span class="keyword">import</span> QiskitRuntimeService</span><br><span class="line"> </span><br><span class="line">service = QiskitRuntimeService(channel=<span class="string">&quot;ibm_quantum&quot;</span>, token=<span class="string">&quot;jujun-api-token&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>每个IBM量子云账号会有一个token</p>
<img src="../images/01.png" alt="01" style="zoom:50%;" />



<h2 id="6-创建量子电路"><a href="#6-创建量子电路" class="headerlink" title="6. 创建量子电路"></a>6. 创建量子电路</h2><h3 id="6-1-QuantumCircuit"><a href="#6-1-QuantumCircuit" class="headerlink" title="6.1 QuantumCircuit"></a>6.1 QuantumCircuit</h3><p>QuantumCircuit是qiskit框架的核心类，它代表了量子电路，在创建了QuantumCircuit之后，可以向它里面添加各种门操作。创建一个<code>QuantumCircuit</code>的基本步骤如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit <span class="keyword">import</span> QuantumCircuit</span><br><span class="line"><span class="comment"># 创建一个包含三个量子比特的量子电路</span></span><br><span class="line">circ = QuantumCircuit(<span class="number">3</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>在创建了<code>QuantumCircuit</code>之后，你可以向其添加各种量子门（电路操作，例如，你可以添加一个Hadamard门（H门）和两个控制非门（CX门或CNOT门）来创建一个GHZ态</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在qubit0上添加一个H门，使量子位形成叠加态</span></span><br><span class="line">circ.h(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 添加一个CX (CNOT)门，qubit 0为控制位，qubit 1为目标位，使量子位形成Bell态</span></span><br><span class="line">circ.cx(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 添加一个CX (CNOT)门，qubit 0位控制位，qubit 2位目标位，使量子位形成GHZ态</span></span><br><span class="line">circ.cx(<span class="number">0</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>你还可以使用Qiskit的<code>QuantumCircuit.draw()</code>模块来可视化你的量子电路：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">circ.draw(<span class="string">&#x27;mpl&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>此外，Qiskit还提供了一些模拟器，如<code>QasmSimulator</code>和<code>statevector_simulator</code>，你可以使用这些模拟器来运行<code>QuantumCircuit</code>并获取结果</p>
<h3 id="6-2-量子逻辑门"><a href="#6-2-量子逻辑门" class="headerlink" title="6.2 量子逻辑门"></a>6.2 量子逻辑门</h3><p>量子逻辑门，常见的有：Pauli metrics、Hadamard gate（用来创造叠加态的一个门）、controlled NOT gate（CNOT）</p>
<h4 id="Pauli-metrics"><a href="#Pauli-metrics" class="headerlink" title="Pauli metrics"></a>Pauli metrics</h4><p>在量子计算中，I、X、Y、Z代表的是Pauli矩阵，也被称为Pauli算子。它们在量子力学和量子计算中起着重要的作用。具体来说：</p>
<ul>
<li><strong>I</strong> 代表的是单位矩阵，它在量子比特上没有任何作用。在Qiskit中，它可以表示为 <code>I</code></li>
<li><strong>X</strong> 代表的是Pauli-X矩阵，也被称为比特翻转门或者NOT门。它会将量子态 |0⟩ 变为 |1⟩，将 |1⟩ 变为 |0⟩。在Qiskit中，它可以表示为 <code>X</code>。</li>
</ul>
<p>$$<br>\left[<br> \begin{matrix}<br>   0 &amp; 1 \<br>   1 &amp; 0<br>  \end{matrix}<br>  \right] \tag{1}<br>$$</p>
<p>例子：<br>$$<br>X|1\rangle&#x3D;\left[<br> \begin{matrix}<br>   0 &amp; 1 \<br>   1 &amp; 0<br>  \end{matrix}<br>  \right]<br>  \left[<br> \begin{matrix}<br>   1\<br>   0<br>  \end{matrix}<br>  \right]&#x3D;\left[<br> \begin{matrix}<br>   0\<br>   1<br>  \end{matrix}<br>  \right]&#x3D;|0\rangle\tag{2}<br>$$</p>
<ul>
<li><strong>Y</strong> 代表的是Pauli-Y矩阵，它是一个在复平面上执行180度旋转的操作（绕y轴转180度）。在Qiskit中，它可以表示为 <code>Y</code>。</li>
</ul>
<p>$$<br>\left[<br> \begin{matrix}<br>   0 &amp; -i \<br>   i &amp; 0<br>  \end{matrix}<br>  \right] \tag{3}<br>$$</p>
<ul>
<li><strong>Z</strong> 代表的是Pauli-Z矩阵，也被称为相位翻转门（绕z轴转180度）。它会将量子态 |0⟩ 变为 |0⟩，将 |1⟩ 变为 -|1⟩。在Qiskit中，它可以表示为 <code>Z</code></li>
</ul>
<p>$$<br>\left[<br> \begin{matrix}<br>   1 &amp; 0 \<br>   0 &amp; -1<br>  \end{matrix}<br>  \right] \tag{4}<br>$$</p>
<p>这些矩阵都是酉矩阵。一个pauli metrics可以表示为：<br>$$<br>\vec{\delta}&#x3D;X\vec{x}+Y\vec{y}+Z\vec{z}\tag{5}<br>$$</p>
<h4 id="Hadamard-Gate"><a href="#Hadamard-Gate" class="headerlink" title="Hadamard Gate"></a>Hadamard Gate</h4><p>$$<br>\frac 1{\sqrt 2}\left[<br> \begin{matrix}<br>   1 &amp; 1 \<br>   1 &amp; -1<br>  \end{matrix}<br>  \right] \tag{6}<br>$$</p>
<p>H门可以用来构造叠加态<br>$$<br>H|0\rangle&#x3D;\frac 1{\sqrt 2}\left[<br> \begin{matrix}<br>   1 &amp; 1 \<br>   1 &amp; -1<br>  \end{matrix}<br>  \right]<br>  \left[<br> \begin{matrix}<br>   1\<br>   0<br>  \end{matrix}<br>  \right]&#x3D;\frac 1{\sqrt 2}<br>  \left[<br>  \begin{matrix}<br>   1\<br>   1<br>  \end{matrix}<br>  \right]&#x3D;\frac {|1\rangle+|0\rangle}{\sqrt 2}\tag{7}<br>$$</p>
<h3 id="6-3-Operator"><a href="#6-3-Operator" class="headerlink" title="6.3 Operator"></a>6.3 Operator</h3><p>Pauli对象和Gate都可以转换成operator对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pauliXX = Pauli(<span class="string">&#x27;XX&#x27;</span>)</span><br><span class="line">Operator(pauliXX)</span><br></pre></td></tr></table></figure>

<p>多个量子逻辑门可以合成一个Operator（算子）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XX = Operator([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure>

<h3 id="6-4-Estimator"><a href="#6-4-Estimator" class="headerlink" title="6.4 Estimator"></a>6.4 Estimator</h3><p>Estimator主要用于来计算量子电路的估计值，其初始化方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">estimator = Estimator(backend=backend,options=options)</span><br></pre></td></tr></table></figure>

<p>用法：</p>
<ul>
<li>初始化可观测量</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit.quantum_info <span class="keyword">import</span> SparsePauliOp</span><br><span class="line"> </span><br><span class="line">observable = SparsePauliOp([<span class="string">&quot;II&quot;</span>, <span class="string">&quot;XX&quot;</span>, <span class="string">&quot;YY&quot;</span>, <span class="string">&quot;ZZ&quot;</span>], coeffs=[<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化QuantumCircuit</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit <span class="keyword">import</span> QuantumCircuit</span><br><span class="line"> </span><br><span class="line">qc = QuantumCircuit(<span class="number">2</span>)</span><br><span class="line">qc.h(<span class="number">0</span>)</span><br><span class="line">qc.cx(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">qc.draw(<span class="string">&quot;mpl&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化Estimator</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit.primitives <span class="keyword">import</span> Estimator</span><br><span class="line"> </span><br><span class="line">estimator = Estimator()</span><br></pre></td></tr></table></figure>

<ul>
<li>运行并获取结果</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">estimator = Estimator(options=options)</span><br><span class="line"> </span><br><span class="line">job = estimator.run(qc, observable)</span><br><span class="line">result = job.result()</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<h3 id="6-5-Sampler"><a href="#6-5-Sampler" class="headerlink" title="6.5 Sampler"></a>6.5 Sampler</h3><p>Sampler主要用于采样量子电路的输出，其初始化方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sampler = Sampler(backend=backend)</span><br></pre></td></tr></table></figure>

<p>用法：</p>
<ul>
<li>初始化QuantumCircuit</li>
<li>初始化Sampler</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit.primitives <span class="keyword">import</span> Sampler</span><br><span class="line"> </span><br><span class="line">sampler = Sampler()</span><br></pre></td></tr></table></figure>

<ul>
<li>运行并获取结果</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">job = sampler.run(qc)</span><br><span class="line">result = job.result()</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<ul>
<li>得到概率分布</li>
</ul>
<h3 id="6-6-控制流"><a href="#6-6-控制流" class="headerlink" title="6.6 控制流"></a>6.6 控制流</h3><ul>
<li>If语句-<a target="_blank" rel="noopener" href="https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#if_test"><code>QuantumCircuit.if_test</code></a></li>
<li>Switch语句-<a target="_blank" rel="noopener" href="https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#switch"><code>QuantumCircuit.switch</code></a></li>
<li>循环-<a target="_blank" rel="noopener" href="https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#for_loop"><code>QuantumCircuit.for_loop</code></a></li>
<li>While循环-<a target="_blank" rel="noopener" href="https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#while_loop"><code>QuantumCircuit.while_loop</code></a></li>
</ul>
<h4 id="If语句"><a href="#If语句" class="headerlink" title="If语句"></a>If语句</h4><p>if语句用于根据经典位或寄存器的值有条件地执行操作。</p>
<p>在下面的例子中，我们对一个量子位应用一个Hadamard门并测量它。如果结果是1，那么我们对量子位应用一个X门，这会使它回到0状态。然后我们再测量量子比特。结果测量结果应为0，概率为100%。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit.circuit <span class="keyword">import</span> QuantumCircuit, QuantumRegister, ClassicalRegister</span><br><span class="line"> </span><br><span class="line">qubits = QuantumRegister(<span class="number">1</span>)</span><br><span class="line">clbits = ClassicalRegister(<span class="number">1</span>)</span><br><span class="line">circuit = QuantumCircuit(qubits, clbits)</span><br><span class="line">(q0,) = qubits</span><br><span class="line">(c0,) = clbits</span><br><span class="line"> </span><br><span class="line">circuit.h(q0)</span><br><span class="line">circuit.measure(q0, c0)</span><br><span class="line"><span class="keyword">with</span> circuit.if_test((c0, <span class="number">1</span>)):</span><br><span class="line">    circuit.x(q0)</span><br><span class="line">circuit.measure(q0, c0)</span><br><span class="line">circuit.draw(<span class="string">&quot;mpl&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># example output counts: &#123;&#x27;0&#x27;: 1024&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>with</code>语句可以被赋予一个赋值目标，它本身就是一个上下文管理器，可以被存储并随后用于创建一个else块，每当if块的内容没有被执行时，它就会被执行。</p>
<p>在下面的例子中，我们用两个量子位和两个经典位初始化寄存器。我们对第一个量子比特应用阿达玛门并测量它。如果结果为1，那么我们对第二个量子比特应用阿达玛门;否则，我们对第二个量子比特应用X门。最后，我们也测量第二个量子比特。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">qubits = QuantumRegister(<span class="number">2</span>)</span><br><span class="line">clbits = ClassicalRegister(<span class="number">2</span>)</span><br><span class="line">circuit = QuantumCircuit(qubits, clbits)</span><br><span class="line">(q0, q1) = qubits</span><br><span class="line">(c0, c1) = clbits</span><br><span class="line"> </span><br><span class="line">circuit.h(q0)</span><br><span class="line">circuit.measure(q0, c0)</span><br><span class="line"><span class="keyword">with</span> circuit.if_test((c0, <span class="number">1</span>)) <span class="keyword">as</span> else_:</span><br><span class="line">    circuit.h(q1)</span><br><span class="line"><span class="keyword">with</span> else_:</span><br><span class="line">    circuit.x(q1)</span><br><span class="line">circuit.measure(q1, c1)</span><br><span class="line"> </span><br><span class="line">circuit.draw(<span class="string">&quot;mpl&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># example output counts: &#123;&#x27;01&#x27;: 260, &#x27;11&#x27;: 272, &#x27;10&#x27;: 492&#125;</span></span><br></pre></td></tr></table></figure>

<p>除了以单个经典位为条件外，还可以以由多个位组成的经典寄存器的值为条件。</p>
<p>在下面的例子中，我们将Hadamard门应用于两个量子比特并测量它们。如果结果是<code>01</code>，也就是说，第一个量子位是1，第二个量子位是0，那么我们将X门应用于第三个量子位。最后，我们测量第三个量子比特。请注意，为了清楚起见，我们选择在if条件中指定第三个经典位的状态，即0。在电路图中，条件由被调节的经典位上的圆圈表示。黑色圆圈表示调节1，而白色圆圈表示调节0。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">qubits = QuantumRegister(<span class="number">3</span>)</span><br><span class="line">clbits = ClassicalRegister(<span class="number">3</span>)</span><br><span class="line">circuit = QuantumCircuit(qubits, clbits)</span><br><span class="line">(q0, q1, q2) = qubits</span><br><span class="line">(c0, c1, c2) = clbits</span><br><span class="line"> </span><br><span class="line">circuit.h([q0, q1])</span><br><span class="line">circuit.measure(q0, c0)</span><br><span class="line">circuit.measure(q1, c1)</span><br><span class="line"><span class="keyword">with</span> circuit.if_test((clbits, <span class="number">0b001</span>)):</span><br><span class="line">    circuit.x(q2)</span><br><span class="line">circuit.measure(q2, c2)</span><br><span class="line"> </span><br><span class="line">circuit.draw(<span class="string">&quot;mpl&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># example output counts: &#123;&#x27;101&#x27;: 269, &#x27;011&#x27;: 260, &#x27;000&#x27;: 252, &#x27;010&#x27;: 243&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="Switch语句"><a href="#Switch语句" class="headerlink" title="Switch语句"></a>Switch语句</h4><p>switch语句用于根据经典位或寄存器的值选择操作。它类似于if语句，但允许为分支逻辑指定更多的情况。在下面的例子中，我们对一个量子比特应用一个Hadamard门并测量它。如果结果是0，我们对量子比特应用一个X门，如果结果是1，我们应用一个Z门。结果测量结果应为1，概率为100%。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">qubits = QuantumRegister(<span class="number">1</span>)</span><br><span class="line">clbits = ClassicalRegister(<span class="number">1</span>)</span><br><span class="line">circuit = QuantumCircuit(qubits, clbits)</span><br><span class="line">(q0,) = qubits</span><br><span class="line">(c0,) = clbits</span><br><span class="line"> </span><br><span class="line">circuit.h(q0)</span><br><span class="line">circuit.measure(q0, c0)</span><br><span class="line"><span class="keyword">with</span> circuit.switch(c0) <span class="keyword">as</span> <span class="keyword">case</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="keyword">case</span>(<span class="number">0</span>):</span><br><span class="line">        circuit.x(q0)</span><br><span class="line">    <span class="keyword">with</span> <span class="keyword">case</span>(<span class="number">1</span>):</span><br><span class="line">        circuit.z(q0)</span><br><span class="line">circuit.measure(q0, c0)</span><br><span class="line"> </span><br><span class="line">circuit.draw(<span class="string">&quot;mpl&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># example output counts: &#123;&#x27;1&#x27;: 1024&#125;</span></span><br></pre></td></tr></table></figure>

<p>因为上面的例子使用了一个单一的经典位，所以只有两种可能的情况，所以我们可以使用if-else语句实现相同的结果。开关情况主要在对由多个位组成的经典寄存器的值进行分支时有用，如以下示例所示。在这里，我们还展示了如何构造一个默认情况，如果前面的情况都不存在，则执行该默认情况。注意，在switch语句中，只有一个块会被执行。不会有任何闪失。</p>
<p>在下面的例子中，我们将Hadamard门应用于两个量子比特并测量它们。如果结果是00或11，我们将Z门应用于第三个量子位。如果结果是01，我们应用Y门。如果前面的情况都不匹配，我们就应用X门。最后，测量第三个量子位。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">qubits = QuantumRegister(<span class="number">3</span>)</span><br><span class="line">clbits = ClassicalRegister(<span class="number">3</span>)</span><br><span class="line">circuit = QuantumCircuit(qubits, clbits)</span><br><span class="line">(q0, q1, q2) = qubits</span><br><span class="line">(c0, c1, c2) = clbits</span><br><span class="line"> </span><br><span class="line">circuit.h([q0, q1])</span><br><span class="line">circuit.measure(q0, c0)</span><br><span class="line">circuit.measure(q1, c1)</span><br><span class="line"><span class="keyword">with</span> circuit.switch(clbits) <span class="keyword">as</span> <span class="keyword">case</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="keyword">case</span>(<span class="number">0b000</span>, <span class="number">0b011</span>):</span><br><span class="line">        circuit.z(q2)</span><br><span class="line">    <span class="keyword">with</span> <span class="keyword">case</span>(<span class="number">0b001</span>):</span><br><span class="line">        circuit.y(q2)</span><br><span class="line">    <span class="keyword">with</span> <span class="keyword">case</span>(<span class="keyword">case</span>.DEFAULT):</span><br><span class="line">        circuit.x(q2)</span><br><span class="line">circuit.measure(q2, c2)</span><br><span class="line"> </span><br><span class="line">circuit.draw(<span class="string">&quot;mpl&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># example output counts: &#123;&#x27;101&#x27;: 267, &#x27;110&#x27;: 249, &#x27;011&#x27;: 265, &#x27;000&#x27;: 243&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="For循环"><a href="#For循环" class="headerlink" title="For循环"></a>For循环</h4><p>for循环用于遍历经典值序列，并在每次迭代期间执行一些操作。</p>
<p>在下面的例子中，我们使用for循环对一个量子比特应用5个X门，然后测量它。因为我们执行了奇数个X门，所以总体效果是将量子比特从0状态翻转到1状态。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">qubits = QuantumRegister(<span class="number">1</span>)</span><br><span class="line">clbits = ClassicalRegister(<span class="number">1</span>)</span><br><span class="line">circuit = QuantumCircuit(qubits, clbits)</span><br><span class="line">(q0,) = qubits</span><br><span class="line">(c0,) = clbits</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> circuit.for_loop(<span class="built_in">range</span>(<span class="number">5</span>)) <span class="keyword">as</span> _:</span><br><span class="line">    circuit.x(q0)</span><br><span class="line">circuit.measure(q0, c0)</span><br><span class="line"> </span><br><span class="line">circuit.draw(<span class="string">&quot;mpl&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># example output counts: &#123;&#x27;1&#x27;: 1024&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="While循环"><a href="#While循环" class="headerlink" title="While循环"></a>While循环</h4><p>while循环用于在满足某些条件时重复指令。</p>
<p>在下面的例子中，我们将Hadamard门应用于两个量子比特并测量它们。然后，我们创建一个while循环，在测量结果为11时重复此过程。因此，最终的测量值永远不会是11，其余的可能性以近似相等的频率出现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">qubits = QuantumRegister(<span class="number">2</span>)</span><br><span class="line">clbits = ClassicalRegister(<span class="number">2</span>)</span><br><span class="line">circuit = QuantumCircuit(qubits, clbits)</span><br><span class="line"> </span><br><span class="line">q0, q1 = qubits</span><br><span class="line">c0, c1 = clbits</span><br><span class="line"> </span><br><span class="line">circuit.h([q0, q1])</span><br><span class="line">circuit.measure(q0, c0)</span><br><span class="line">circuit.measure(q1, c1)</span><br><span class="line"><span class="keyword">with</span> circuit.while_loop((clbits, <span class="number">0b11</span>)):</span><br><span class="line">    circuit.h([q0, q1])</span><br><span class="line">    circuit.measure(q0, c0)</span><br><span class="line">    circuit.measure(q1, c1)</span><br><span class="line"> </span><br><span class="line">circuit.draw(<span class="string">&quot;mpl&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># example output counts: &#123;&#x27;01&#x27;: 334, &#x27;10&#x27;: 368, &#x27;00&#x27;: 322&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="7-在实际量子硬件上运行"><a href="#7-在实际量子硬件上运行" class="headerlink" title="7.在实际量子硬件上运行"></a>7.在实际量子硬件上运行</h2><p>IBM提供了量子云服务，来让你的程序跑在实际的量子硬件上。通过<strong>API Token</strong>连接到云平台，每个月有10分钟的免费计算时长</p>
<p><img src="/../../../Qiskit-learn/01.png" alt="01"></p>
<h3 id="7-1-设置IBM-Quantum-Channel"><a href="#7-1-设置IBM-Quantum-Channel" class="headerlink" title="7.1 设置IBM Quantum Channel"></a>7.1 设置IBM Quantum Channel</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit_ibm_runtime <span class="keyword">import</span> QiskitRuntimeService</span><br><span class="line"> </span><br><span class="line">service = QiskitRuntimeService(channel=<span class="string">&quot;ibm_quantum&quot;</span>, token=<span class="string">&quot;jujun-api-token&quot;</span>)</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="7-2-在IBM量子云上运行"><a href="#7-2-在IBM量子云上运行" class="headerlink" title="7.2 在IBM量子云上运行"></a>7.2 在IBM量子云上运行</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit_ibm_runtime <span class="keyword">import</span> QiskitRuntimeService</span><br><span class="line"><span class="keyword">from</span> qiskit <span class="keyword">import</span> QuantumCircuit</span><br><span class="line"><span class="keyword">from</span> qiskit_ibm_runtime <span class="keyword">import</span> QiskitRuntimeService, Sampler</span><br><span class="line"><span class="comment"># Save an IBM Quantum account and set it as your default account.</span></span><br><span class="line">QiskitRuntimeService.save_account(channel=<span class="string">&quot;ibm_quantum&quot;</span>, token=<span class="string">&quot;jujun—-api-token&quot;</span>, set_as_default=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Load saved credentials</span></span><br><span class="line">service = QiskitRuntimeService()</span><br><span class="line">example_circuit = QuantumCircuit(<span class="number">2</span>)</span><br><span class="line">example_circuit.measure_all()</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># You&#x27;ll need to specify the credentials when initializing QiskitRuntimeService, if they were not previously saved.</span></span><br><span class="line">service = QiskitRuntimeService()</span><br><span class="line">backend = service.backend(<span class="string">&quot;ibmq_qasm_simulator&quot;</span>)</span><br><span class="line">job = Sampler(backend).run(example_circuit)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;job id: <span class="subst">&#123;job.job_id()&#125;</span>&quot;</span>)</span><br><span class="line">result = job.result()</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1423754031458582528">https://www.zhihu.com/column/c_1423754031458582528</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.quantum.ibm.com/">https://docs.quantum.ibm.com</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/Qiskit#cite_note-5">https://zh.wikipedia.org/zh-cn/Qiskit#cite_note-5</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"></div><div id="disqus_thread"></div><script>var disqus_shortname = 'https-miller-star-github-io';
var disqus_identifier = '2024/03/06/qiskit安装与使用/';
var disqus_title = 'qiskit安装与使用';
var disqus_url = 'http://example.com/2024/03/06/qiskit安装与使用/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//https-miller-star-github-io.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2024 <a href="http://example.com">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>