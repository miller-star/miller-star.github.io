<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>kubernetes教程</title>
    <url>/2024/04/08/kubernetes%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>控制平面</p>
<p>业务平面</p>
]]></content>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>qiskit使用教程</title>
    <url>/2024/04/09/qiskit%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="python安装"><a href="#python安装" class="headerlink" title="python安装"></a>python安装</h3><p>windows系统参考：<a class="link"   href="https://zhuanlan.zhihu.com/p/636134381" >https://zhuanlan.zhihu.com/p/636134381<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="安装qiskit"><a href="#安装qiskit" class="headerlink" title="安装qiskit"></a>安装qiskit</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install qiskit</span><br><span class="line">pip install qiskit-ibm-runtime</span><br></pre></td></tr></table></figure>

<h2 id="qiskit框架代码编写流程"><a href="#qiskit框架代码编写流程" class="headerlink" title="qiskit框架代码编写流程"></a>qiskit框架代码编写流程</h2><ul>
<li>构建</li>
<li>转译：某些特殊的门只能在特定的量子硬件上运行，所以需要转译这一步</li>
<li>验证</li>
</ul>
<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><h3 id="量子电路"><a href="#量子电路" class="headerlink" title="量子电路"></a>量子电路</h3><p>QuantumCircuit是qiskit框架的核心类，它代表了量子电路，在创建了QuantumCircuit之后，可以向它里面添加各种门操作。创建一个QuantumCircuit的基本步骤如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from qiskit import QuantumCircuit</span><br><span class="line"># 创建一个包含三个量子比特的量子电路</span><br><span class="line">circ = QuantumCircuit(3,2)</span><br></pre></td></tr></table></figure>

<p>在创建了QuantumCircuit之后，你可以向其添加各种量子门（电路操作，例如，你可以添加一个Hadamard门（H门）和两个控制非门（CX门或CNOT门）来创建一个GHZ态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在qubit0上添加一个H门，使量子位形成叠加态</span><br><span class="line">circ.h(0)</span><br><span class="line"># 添加一个CX (CNOT)门，qubit 0为控制位，qubit 1为目标位，使量子位形成Bell态</span><br><span class="line">circ.cx(0,1)</span><br><span class="line"># 添加一个CX (CNOT)门，qubit 0位控制位，qubit 2位目标位，使量子位形成GHZ态</span><br><span class="line">circ.cx(0,2)</span><br><span class="line"># 控制位更改</span><br><span class="line">circ.cx(0,1,ctrl_state=0)</span><br></pre></td></tr></table></figure>

<p>详细：<a class="link"   href="https://docs.quantum.ibm.com/api/qiskit/circuit_library" >https://docs.quantum.ibm.com/api/qiskit/circuit_library<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from qiskit.circuit.library import HGate</span><br><span class="line"> </span><br><span class="line">qc = QuantumCircuit(1)</span><br><span class="line">qc.append(</span><br><span class="line">    HGate(),  # New HGate instruction</span><br><span class="line">    [0]       # Apply to qubit 0</span><br><span class="line">)</span><br><span class="line">qc.draw(&quot;mpl&quot;)</span><br></pre></td></tr></table></figure>

<h4 id="组合电路"><a href="#组合电路" class="headerlink" title="组合电路"></a>组合电路</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qc_a = QuantumCircuit(4)</span><br><span class="line">qc_a.x(0)</span><br><span class="line"> </span><br><span class="line">qc_b = QuantumCircuit(2, name=&quot;qc_b&quot;)</span><br><span class="line">qc_b.y(0)</span><br><span class="line">qc_b.z(1)</span><br><span class="line"> </span><br><span class="line"># compose qubits (0, 1) of qc_a to qubits (1, 3) of qc_b respectively</span><br><span class="line">combined = qc_a.compose(qc_b, qubits=[1, 3])</span><br><span class="line">combined.draw(&quot;mpl&quot;)</span><br></pre></td></tr></table></figure>

<p>使用to_instruction方法将电路转化为指令，然后附加到另一个电路</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inst = qc_b.to_instruction()</span><br><span class="line">qc_a.append(inst, [1, 3])</span><br><span class="line">qc_a.draw(&quot;mpl&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h3><p>Qiskit SDK 中的Operator类用于表示作用于量子系统的矩阵算子。它有几种方法，可以使用较小算子的张量乘积来构建复合算子，并组成算子。</p>
<h4 id="创建Operator"><a href="#创建Operator" class="headerlink" title="创建Operator"></a>创建Operator</h4><p>创建算子对象的最简单方法是用列表或 Numpy 数组形式的矩阵进行初始化。例如，创建一个双量子位Pauli-XX 运算符：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> qiskit_aer <span class="keyword">import</span> Aer</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> qiskit <span class="keyword">import</span> QuantumCircuit, ClassicalRegister, QuantumRegister</span><br><span class="line"><span class="keyword">from</span> qiskit.quantum_info.operators <span class="keyword">import</span> Operator, Pauli</span><br><span class="line"><span class="keyword">from</span> qiskit.quantum_info <span class="keyword">import</span> process_fidelity</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> qiskit.circuit.library <span class="keyword">import</span> RXGate, XGate, CXGate</span><br><span class="line">XX = Operator([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line">XX</span><br></pre></td></tr></table></figure>

<h4 id="Operator类的属性"><a href="#Operator类的属性" class="headerlink" title="Operator类的属性"></a>Operator类的属性</h4><p>Operator对象存储底层矩阵以及子系统的输入和输出维度。</p>
<p>data：要访问底层 Numpy 数组，我们可以使用 Operator.data 属性。<br>dims：要返回运算符的总输入和输出维度，我们可以使用 Operator.dim 属性。注意：输出返回的是一个元组（input_dim, output_dim），与底层矩阵的形状相反。</p>
<h4 id="输入和输出维度"><a href="#输入和输出维度" class="headerlink" title="输入和输出维度"></a>输入和输出维度</h4><p>运算符类还会跟踪子系统维度，这些维度可用于将运算符组合在一起。可以使用 input_dims 和 output_dims 函数访问这些信息。对于一个2^m*2^n的operator，将自动假定输入和输出维度分别为 M 量子比特和 N 量子比特。</p>
<h4 id="将别的类转换为operator"><a href="#将别的类转换为operator" class="headerlink" title="将别的类转换为operator"></a>将别的类转换为operator</h4><p>有三种可以转换为operator的类</p>
<ul>
<li>Pauli对象</li>
<li>门（Gate）</li>
<li>量子电路（circuit）</li>
</ul>
<h4 id="在量子电路中使用operator"><a href="#在量子电路中使用operator" class="headerlink" title="在量子电路中使用operator"></a>在量子电路中使用operator</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create an operator</span></span><br><span class="line">XX = Operator(Pauli(<span class="string">&#x27;XX&#x27;</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Add to a circuit</span></span><br><span class="line">circ = QuantumCircuit(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">circ.append(XX, [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">circ.measure([<span class="number">0</span>,<span class="number">1</span>], [<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">circ.draw(<span class="string">&#x27;mpl&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="组合operator"><a href="#组合operator" class="headerlink" title="组合operator"></a>组合operator</h4><h4 id="张量积"><a href="#张量积" class="headerlink" title="张量积"></a>张量积</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = Operator(Pauli(<span class="string">&#x27;X&#x27;</span>))</span><br><span class="line">B = Operator(Pauli(<span class="string">&#x27;Z&#x27;</span>))</span><br><span class="line">A.tensor(B)</span><br><span class="line">A.expend(B)</span><br></pre></td></tr></table></figure>

<p>张量积，<img   src="https://cdn.nlark.com/yuque/__latex/ffa6d2f50d5ca82892caeee5880860f2.svg"  alt="img"></p>
<h5 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = Operator(Pauli(<span class="string">&#x27;X&#x27;</span>))</span><br><span class="line">B = Operator(Pauli(<span class="string">&#x27;Z&#x27;</span>))</span><br><span class="line">A.compose(B, front=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>矩阵乘法，B.A</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h3 id="Sampler"><a href="#Sampler" class="headerlink" title="Sampler"></a>Sampler</h3><p>Sampler主要用于采样量子电路的输出，其初始化方法如下：</p>
<p>sampler &#x3D; Sampler(backend&#x3D;backend)</p>
<p>用法：</p>
<ul>
<li>初始化QuantumCircuit</li>
<li>初始化Sampler</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from qiskit.primitives import Sampler</span><br><span class="line"> </span><br><span class="line">sampler = Sampler()</span><br></pre></td></tr></table></figure>

<ul>
<li>运行并获取结果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">job = sampler.run(qc)</span><br><span class="line">result = job.result()</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>



<h3 id="Estimator"><a href="#Estimator" class="headerlink" title="Estimator"></a>Estimator</h3><p>在Qiskit中，<code>Estimator</code>是一个用于估计量子电路和可观测量的期望值的工具。它的<code>run()</code>方法可以用来提交电路、可观测量和参数到<code>Estimator</code>。</p>
<p><code>Estimator</code>的主要参数包括：</p>
<ul>
<li><code>circuits</code>：一个或多个量子电路对象。</li>
<li><code>observables</code>：一个或多个可观测量对象。</li>
<li><code>parameter_values</code>：具体的参数值。</li>
<li><code>run_options</code>：用于电路执行的运行选项。</li>
</ul>
<p><code>Estimator</code>的<code>run</code>方法将返回一个<code>EstimatorResult</code>对象，这个对象包含了期望值的估计结果。</p>
<p>例如，如果你有一个量子电路<code>circuit</code>和一个可观测量<code>observable</code>，你可以使用<code>Estimator</code>来计算可观测量的期望值¹³：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">estimator = Estimator(...)</span><br><span class="line">result = estimator.run(circuits=circuit, observables=observable)</span><br></pre></td></tr></table></figure>



<p>这将返回一个<code>EstimatorResult</code>对象，其中包含了可观测量的期望值。</p>
<h2 id="官方文档事例"><a href="#官方文档事例" class="headerlink" title="官方文档事例"></a>官方文档事例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit <span class="keyword">import</span> QuantumCircuit</span><br><span class="line"><span class="keyword">from</span> qiskit.quantum_info <span class="keyword">import</span> SparsePauliOp</span><br><span class="line"><span class="keyword">from</span> qiskit.transpiler.preset_passmanagers <span class="keyword">import</span> generate_preset_pass_manager</span><br><span class="line"><span class="keyword">from</span> qiskit_ibm_runtime <span class="keyword">import</span> QiskitRuntimeService, EstimatorV2 <span class="keyword">as</span> Estimator</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># Create a new circuit with two qubits (first argument) and two classical</span></span><br><span class="line"><span class="comment"># bits (second argument)</span></span><br><span class="line">qc = QuantumCircuit(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Add a Hadamard gate to qubit 0</span></span><br><span class="line">qc.h(<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Perform a controlled-X gate on qubit 1, controlled by qubit 0</span></span><br><span class="line">qc.cx(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Return a drawing of the circuit using MatPlotLib (&quot;mpl&quot;). This is the</span></span><br><span class="line"><span class="comment"># last line of the cell, so the drawing appears in the cell output.</span></span><br><span class="line"><span class="comment"># Remove the &quot;mpl&quot; argument to get a text drawing.</span></span><br><span class="line">qc.draw(<span class="string">&quot;mpl&quot;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># Set up six different observables.</span></span><br><span class="line">observables_labels = [<span class="string">&quot;ZZ&quot;</span>, <span class="string">&quot;ZI&quot;</span>, <span class="string">&quot;IZ&quot;</span>, <span class="string">&quot;XX&quot;</span>, <span class="string">&quot;XI&quot;</span>]</span><br><span class="line">observables = [SparsePauliOp(label) <span class="keyword">for</span> label <span class="keyword">in</span> observables_labels]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Construct the Estimator instance we want to use.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># If you did not previously save your credentials, use the following line instead:</span></span><br><span class="line"><span class="comment"># service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;, token=&quot;&lt;MY_IBM_QUANTUM_TOKEN&gt;&quot;)</span></span><br><span class="line">service = QiskitRuntimeService()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Run on the least-busy backend you have access to</span></span><br><span class="line"><span class="comment">#backend = service.least_busy(simulator=False, operational=True)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Use the following code instead if you want to run on a simulator:</span></span><br><span class="line"><span class="keyword">from</span> qiskit_ibm_runtime.fake_provider <span class="keyword">import</span> FakeCairoV2</span><br><span class="line">backend = FakeCairoV2()</span><br><span class="line"> </span><br><span class="line">estimator = Estimator(backend)</span><br><span class="line">estimator.options.resilience_level = <span class="number">1</span></span><br><span class="line">estimator.options.default_shots = <span class="number">5000</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Convert to an ISA circuit and layout-mapped observables.</span></span><br><span class="line">pm = generate_preset_pass_manager(backend=backend, optimization_level=<span class="number">1</span>)</span><br><span class="line">isa_circuit = pm.run(qc)</span><br><span class="line">observables = [</span><br><span class="line">    observable.apply_layout(isa_circuit.layout) <span class="keyword">for</span> observable <span class="keyword">in</span> observables</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># One pub, with one circuit to run against five different observables.</span></span><br><span class="line">job = estimator.run([(isa_circuit, observables)])</span><br><span class="line"> </span><br><span class="line"><span class="comment"># This is the result of the entire submission.  We submitted one Pub,</span></span><br><span class="line"><span class="comment"># so this contains one inner result (and some metadata of its own).</span></span><br><span class="line">job_result = job.result()</span><br><span class="line"><span class="built_in">print</span>(job_result)</span><br><span class="line"><span class="comment"># This is the result from our single pub, which had five observables,</span></span><br><span class="line"><span class="comment"># so contains information on all five.</span></span><br><span class="line">pub_result = job.result()[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(pub_result)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>



<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>你还可以使用Qiskit的QuantumCircuit.draw()模块来可视化你的量子电路：</p>
<p>circ.draw(‘mpl’)</p>
<p>此外，Qiskit还提供了一些模拟器，如QasmSimulator和statevector_simulator，你可以使用这些模拟器来运行QuantumCircuit并获取结果</p>
<p>在量子力学中，观测量是一个可以在一个量子系统上进行测量的物理量，比如位置、动量、自旋等。在Qiskit中，观测量通常表示为一个算符，这个算符作用在一个量子态上，可以给出一个实数结果。</p>
<p>SparsePauliOp可以用作观测量，因为它是一个量子算符，可以用来描述一个量子系统的物理性质。当我们对一个量子系统进行测量时，我们实际上是在查看这个算符在特定量子态下的期望值。例如，如果我们有一个量子态</p>
<p><img   src="https://cdn.nlark.com/yuque/__latex/9a959d50961ff6d077ec648bbb5bb720.svg"  alt="img"></p>
<p>和一个观测量</p>
<p><img   src="https://cdn.nlark.com/yuque/__latex/7b1415efd6f3f1605dd2ab4e89761827.svg"  alt="img"></p>
<p>，那么这个观测量在这个量子态下的期望值可以表示为</p>
<p><img   src="https://cdn.nlark.com/yuque/__latex/02c7d59d144ceaa8d23ead7cf6d7b9ba.svg"  alt="img"></p>
<p>。</p>
<p><a class="link"   href="https://zhuanlan.zhihu.com/p/484552880" >在Qiskit中，我们可以使用~StateFn来创建一个对偶向量，即ket对应的bra<i class="fas fa-external-link-alt"></i></a><a class="link"   href="https://zhuanlan.zhihu.com/p/484552880" >1<i class="fas fa-external-link-alt"></i></a><a class="link"   href="https://zhuanlan.zhihu.com/p/484552880" >。然后，我们可以使用@操作符来计算一个量子态和一个观测量之间的内积，得到观测量的期望值<i class="fas fa-external-link-alt"></i></a><a class="link"   href="https://zhuanlan.zhihu.com/p/484552880" >1<i class="fas fa-external-link-alt"></i></a>。</p>
<h2 id="创建service与backend"><a href="#创建service与backend" class="headerlink" title="创建service与backend"></a>创建service与backend</h2><p>首先查看后端类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Initialize your account</span><br><span class="line">from qiskit_ibm_runtime import QiskitRuntimeService</span><br><span class="line">service = QiskitRuntimeService()</span><br><span class="line">service.backends()</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&lt;IBMBackend(&#x27;ibmq_qasm_simulator&#x27;)&gt;,</span><br><span class="line"> &lt;IBMBackend(&#x27;ibmq_mumbai&#x27;)&gt;,</span><br><span class="line"> &lt;IBMBackend(&#x27;ibm_hanoi&#x27;)&gt;,</span><br><span class="line"> &lt;IBMBackend(&#x27;ibm_osaka&#x27;)&gt;,</span><br><span class="line"> &lt;IBMBackend(&#x27;ibm_cusco&#x27;)&gt;,</span><br><span class="line"> &lt;IBMBackend(&#x27;ibm_sherbrooke&#x27;)&gt;,</span><br><span class="line"> &lt;IBMBackend(&#x27;ibm_nazca&#x27;)&gt;,</span><br><span class="line"> &lt;IBMBackend(&#x27;ibm_kyoto&#x27;)&gt;,</span><br><span class="line"> &lt;IBMBackend(&#x27;ibm_cairo&#x27;)&gt;,</span><br><span class="line"> &lt;IBMBackend(&#x27;ibmq_kolkata&#x27;)&gt;,</span><br><span class="line"> &lt;IBMBackend(&#x27;ibm_brisbane&#x27;)&gt;,</span><br><span class="line"> &lt;IBMBackend(&#x27;ibm_algiers&#x27;)&gt;,</span><br><span class="line"> &lt;IBMBackend(&#x27;ibm_torino&#x27;)&gt;]</span><br></pre></td></tr></table></figure>

<p>根据后端类型，创建一个service</p>
<p>service.backend(“ibmq_qasm_simulator”)</p>
<h3 id="设置IBM-Quantum-Channel"><a href="#设置IBM-Quantum-Channel" class="headerlink" title="设置IBM Quantum Channel"></a>设置IBM Quantum Channel</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from qiskit_ibm_runtime import QiskitRuntimeService</span><br><span class="line"> </span><br><span class="line">service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;, token=&quot;jujun-api-token&quot;)</span><br></pre></td></tr></table></figure>

<p>每个IBM量子云账号会有一个token</p>
]]></content>
      <tags>
        <tag>量子计算</tag>
      </tags>
  </entry>
</search>
