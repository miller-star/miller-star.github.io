<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-12-11T02:53:15.702Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>gorm笔记</title>
    <link href="http://example.com/2024/12/11/%E6%95%B0%E6%8D%AE%E5%BA%93/gorm%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/12/11/%E6%95%B0%E6%8D%AE%E5%BA%93/gorm%E7%AC%94%E8%AE%B0/</id>
    <published>2024-12-11T02:53:04.019Z</published>
    <updated>2024-12-11T02:53:15.702Z</updated>
    
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>kafka论文解读</title>
    <link href="http://example.com/2024/12/01/web%E5%BC%80%E5%8F%91/kafka%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/"/>
    <id>http://example.com/2024/12/01/web%E5%BC%80%E5%8F%91/kafka%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/</id>
    <published>2024-12-01T14:00:52.258Z</published>
    <updated>2024-12-01T14:10:25.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="架构详解"><a href="#架构详解" class="headerlink" title="架构详解"></a>架构详解</h2><p>相比rabbitmq等 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;架构详解&quot;&gt;&lt;a href=&quot;#架构详解&quot; class=&quot;headerlink&quot; title=&quot;架构详解&quot;&gt;&lt;/a&gt;架构详解&lt;/h2&gt;&lt;p&gt;相比rabbitmq等
 &lt;/p&gt;
</summary>
      
    
    
    
    <category term="web开发" scheme="http://example.com/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>git笔记</title>
    <link href="http://example.com/2024/11/25/%E9%9A%8F%E7%AC%94/git%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/11/25/%E9%9A%8F%E7%AC%94/git%E7%AC%94%E8%AE%B0/</id>
    <published>2024-11-25T02:36:43.116Z</published>
    <updated>2024-11-25T06:10:37.177Z</updated>
    
    <content type="html"><![CDATA[<p>撤销尚未add的修改：<br>git checkout – filepath</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;撤销尚未add的修改：&lt;br&gt;git checkout – filepath&lt;/p&gt;
</summary>
      
    
    
    
    <category term="goframe框架" scheme="http://example.com/categories/goframe%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>堆结构详解-golang</title>
    <link href="http://example.com/2024/11/25/golang/%E5%A0%86%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3-golang/"/>
    <id>http://example.com/2024/11/25/golang/%E5%A0%86%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3-golang/</id>
    <published>2024-11-25T01:50:09.545Z</published>
    <updated>2024-11-25T01:52:36.070Z</updated>
    
    <content type="html"><![CDATA[<p>堆用于管理数据集中元素以保持一定顺序</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;堆用于管理数据集中元素以保持一定顺序&lt;/p&gt;
</summary>
      
    
    
    
    <category term="golang" scheme="http://example.com/categories/golang/"/>
    
    
    <category term="golang" scheme="http://example.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2024/11/23/redis%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>http://example.com/2024/11/23/redis%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7/</id>
    <published>2024-11-23T13:53:58.150Z</published>
    <updated>2024-11-27T07:49:01.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p>读取数据的情况比较简单，先读redis，redis没有的话，再读数据库，之后将数据更新到redis<br><img   src="https://blog-picture-a.oss-cn-shanghai.aliyuncs.com/20241123224837.png"  alt="image.png"></p><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p>其实写请求，才是造成大多数一致性问题的原因<br>一般来说，针对写请求有四个策略</p><ul><li>更新数据库后更新缓存</li><li>更新数据库前更新缓存</li><li>更新数据库前删除缓存</li><li>更新数据库后删除缓存<br>接来来，我们分别说一下这四种情况</li></ul><h4 id="先更新数据库后更新缓存"><a href="#先更新数据库后更新缓存" class="headerlink" title="先更新数据库后更新缓存"></a>先更新数据库后更新缓存</h4><table><thead><tr><th>时间</th><th>线程A（写请求）</th><th>线程B（写请求）</th><th>问题</th></tr></thead><tbody><tr><td>T1</td><td>更新数据库为99</td><td></td><td></td></tr><tr><td>T2</td><td></td><td>更新数据库为98</td><td></td></tr><tr><td>T3</td><td></td><td>更新缓存数据为98</td><td></td></tr><tr><td>T4</td><td>更新缓存数据为99</td><td></td><td>此时缓存的值被显式更新为99，但是实际上数据库的值已经是98，数据不一致</td></tr></tbody></table><h4 id="先更新缓存再更新数据库"><a href="#先更新缓存再更新数据库" class="headerlink" title="先更新缓存再更新数据库"></a>先更新缓存再更新数据库</h4><p>这是最不靠谱的一种方案</p><p>因为更新数据库不一定成功，如果数据库没有更新成功，那么读到的就不是脏数据了，而是<code>错误数据</code>了</p><h4 id="先删除缓存再更新数据库"><a href="#先删除缓存再更新数据库" class="headerlink" title="先删除缓存再更新数据库"></a>先删除缓存再更新数据库</h4><p>这么做，写写并发的时候没有问题，但是读写并发的时候有问题</p><table><thead><tr><th>时间</th><th>线程A（写请求）</th><th>线程B（读请求）</th><th>问题</th></tr></thead><tbody><tr><td>T1</td><td>删除缓存值</td><td></td><td></td></tr><tr><td>T2</td><td></td><td>1.读取缓存数据，缓存缺失，从数据库读取数据100</td><td></td></tr><tr><td>T3</td><td>更新数据库中的数据X的值为99</td><td></td><td></td></tr><tr><td>T4</td><td></td><td>将数据100的值写入缓存</td><td>此时缓存的值被显式更新为100，但是实际上数据库的值已经是99了</td></tr><tr><td>针对这种场景，有个做法是所谓的<strong>“延迟双删策略”</strong>，就是说，既然可能因为读请求把一个旧的值又写回去，那么我在写请求处理完之后，等到差不多的时间延迟再重新删除这个缓存值。</td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>时间</th><th>线程A（写请求）</th><th>线程C（新的读请求）</th><th>线程D（新的读请求）</th><th>问题</th></tr></thead><tbody><tr><td>T5</td><td>sleep(N)</td><td>缓存存在，读取到缓存旧值100</td><td></td><td>其他线程可能在双删成功前读到脏数据</td></tr><tr><td>T6</td><td>删除缓存值</td><td></td><td></td><td></td></tr><tr><td>T7</td><td></td><td></td><td>缓存缺失，从数据库读取数据的最新值（99）</td><td></td></tr><tr><td>如果N的时间设置得太短，那么删除缓存还是在读线程C更新缓存之前，那么还是脏数据</td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="先更新数据库后删除缓存"><a href="#先更新数据库后删除缓存" class="headerlink" title="先更新数据库后删除缓存"></a>先更新数据库后删除缓存</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;读取数据&quot;&gt;&lt;a href=&quot;#读取数据&quot; class=&quot;headerlink&quot; title=&quot;读取数据&quot;&gt;&lt;/a&gt;读取数据&lt;/h2&gt;&lt;p&gt;读取数据的情况比较简单，先读redis，redis没有的话，再读数据库，之后将数据更新到redis&lt;br&gt;&lt;img   sr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2024/11/20/Mysql%E8%A1%A8%E8%BF%9E%E6%8E%A5/"/>
    <id>http://example.com/2024/11/20/Mysql%E8%A1%A8%E8%BF%9E%E6%8E%A5/</id>
    <published>2024-11-20T06:49:24.071Z</published>
    <updated>2024-11-20T06:49:42.334Z</updated>
    
    <content type="html"><![CDATA[<p>等值连接</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;等值连接&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mysql是怎样运行的｜第一章</title>
    <link href="http://example.com/2024/11/19/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%EF%BD%9C%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>http://example.com/2024/11/19/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%EF%BD%9C%E7%AC%AC%E4%B8%80%E7%AB%A0/</id>
    <published>2024-11-19T10:56:32.561Z</published>
    <updated>2024-11-19T10:57:17.981Z</updated>
    
    
    
    
    <category term="mysql" scheme="http://example.com/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://example.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Go的slice</title>
    <link href="http://example.com/2024/11/16/golang/Go%E7%9A%84slice/"/>
    <id>http://example.com/2024/11/16/golang/Go%E7%9A%84slice/</id>
    <published>2024-11-16T04:58:43.992Z</published>
    <updated>2024-11-16T04:59:35.579Z</updated>
    
    <content type="html"><![CDATA[<p>go的切片，slice[2:4],左闭右开</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;go的切片，slice[2:4],左闭右开&lt;/p&gt;
</summary>
      
    
    
    
    <category term="golang" scheme="http://example.com/categories/golang/"/>
    
    
    <category term="golang" scheme="http://example.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>IDE配置</title>
    <link href="http://example.com/2024/10/22/%E9%9A%8F%E7%AC%94/IDE%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2024/10/22/%E9%9A%8F%E7%AC%94/IDE%E9%85%8D%E7%BD%AE/</id>
    <published>2024-10-22T07:27:41.884Z</published>
    <updated>2024-11-29T10:49:06.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h2><p>打开github copilot chat ：cmd+ctrl+I<br>cw 快速修改文本<br><img   src="https://raw.githubusercontent.com/miller-star/picture/master/20241022164151.png"  alt="image.png"></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Cmd+D(gb)</td><td>选择下一个匹配项，也是选择光标所在单词</td></tr><tr><td>Cmd+K Cmd+D</td><td>跳过当前选择项</td></tr><tr><td>cmd+u</td><td>回到上一个</td></tr><tr><td>cmd+shift+space</td><td>函数提示</td></tr><tr><td>cmd+option+i</td><td>结构体字段提示</td></tr><tr><td>cmd+shift+L</td><td>多选</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;vscode&quot;&gt;&lt;a href=&quot;#vscode&quot; class=&quot;headerlink&quot; title=&quot;vscode&quot;&gt;&lt;/a&gt;vscode&lt;/h2&gt;&lt;p&gt;打开github copilot chat ：cmd+ctrl+I&lt;br&gt;cw 快速修改文本&lt;br&gt;&lt;img</summary>
      
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>正向代理、反向代理、reverseproxy</title>
    <link href="http://example.com/2024/10/17/web%E5%BC%80%E5%8F%91/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81reverseproxy/"/>
    <id>http://example.com/2024/10/17/web%E5%BC%80%E5%8F%91/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81reverseproxy/</id>
    <published>2024-10-17T01:54:56.280Z</published>
    <updated>2024-10-18T03:11:22.089Z</updated>
    
    <content type="html"><![CDATA[<p>这里说下我理解的正反向代理与golang的reverse_proxy如何实现代理</p><h2 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h2><p>正向代理与反向代理的核心区别在于其目的（或者说作用的对象）</p><ul><li>正向代理：帮客户端进行请求代理，发给服务器</li><li>反向代理，帮服务端处理</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里说下我理解的正反向代理与golang的reverse_proxy如何实现代理&lt;/p&gt;
&lt;h2 id=&quot;正向代理与反向代理&quot;&gt;&lt;a href=&quot;#正向代理与反向代理&quot; class=&quot;headerlink&quot; title=&quot;正向代理与反向代理&quot;&gt;&lt;/a&gt;正向代理与反向代理&lt;/</summary>
      
    
    
    
    <category term="web开发" scheme="http://example.com/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>go work实践</title>
    <link href="http://example.com/2024/10/09/golang/go%20work%E5%AE%9E%E8%B7%B5/"/>
    <id>http://example.com/2024/10/09/golang/go%20work%E5%AE%9E%E8%B7%B5/</id>
    <published>2024-10-09T03:29:26.006Z</published>
    <updated>2024-10-09T03:33:49.817Z</updated>
    
    <content type="html"><![CDATA[<p>go work在1.18引入<br>旨在解决本地开发多module场景，传统的go module不优雅的问题</p><p>1.18之前</p><ul><li>当go.mod中引用的moudle未在github发布，那么go mod tidy时候会报错（多moudle开发的时候经常会遇到这个问题）</li><li>需要在go.mod文件中进行replace替换成本地包，但是push的时候，有需要将其修改回来<br>引入工作区模式之后：</li><li>不需要在go.mod中替换，在go.work文件中替换即可</li><li>go.work文件不提交到代码库</li></ul><p>需要注意的是</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;go work在1.18引入&lt;br&gt;旨在解决本地开发多module场景，传统的go module不优雅的问题&lt;/p&gt;
&lt;p&gt;1.18之前&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当go.mod中引用的moudle未在github发布，那么go mod tidy时候会报错（多moudle开</summary>
      
    
    
    
    <category term="golang" scheme="http://example.com/categories/golang/"/>
    
    
    <category term="golang" scheme="http://example.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>cobra实践</title>
    <link href="http://example.com/2024/09/13/golang/cobra%E5%AE%9E%E8%B7%B5/"/>
    <id>http://example.com/2024/09/13/golang/cobra%E5%AE%9E%E8%B7%B5/</id>
    <published>2024-09-13T10:59:43.715Z</published>
    <updated>2024-09-13T11:00:10.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;</summary>
      
    
    
    
    <category term="golang" scheme="http://example.com/categories/golang/"/>
    
    
    <category term="golang" scheme="http://example.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang包管理</title>
    <link href="http://example.com/2024/09/09/golang/golang%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2024/09/09/golang/golang%E5%8C%85%E7%AE%A1%E7%90%86/</id>
    <published>2024-09-09T07:29:30.736Z</published>
    <updated>2024-12-11T09:39:06.287Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下go moudle相关内容</p><p>golang的包管理经历了GOPATH、go vendor、go moudle三个阶段</p><h3 id="GOPATH机制"><a href="#GOPATH机制" class="headerlink" title="GOPATH机制"></a>GOPATH机制</h3><p>golang的package主要分为三种</p><ul><li>标准库</li><li>第三方库</li><li>项目私库<br>项目会放在GOPATH&#x2F;src目录下<br>这种方式有一个问题，就是当你有两个项目A、B依赖了同一个第三方库C的不同版本，只能维护两个GOPATH</li></ul><blockquote><p>由于编译器依赖查找固定从GOPATH&#x2F;src下查找<code>GOPATH/src/T</code>，所以，无法在同一个GOPATH目录下保存第三方库T的两个版本</p></blockquote><p>为了解决这个问题，引入GOVENDOR机制</p><h3 id="go-vendor"><a href="#go-vendor" class="headerlink" title="go vendor"></a>go vendor</h3><p>go vendor机制将依赖放在项目目录中，从而隔离了不同项目，不同项目可以引用同一个第三方库的不同版本。<br>但是这会导致两个问题</p><p>比如：项目A中依赖了B、C两个第三方库，而B也依赖了C这个库，就会到导致两个问题：</p><ol><li>C被两次编译进A项目的可执行文件</li><li>再进一步，如果两个C的版本不一致，也会有兼容性问题</li></ol><h3 id="go-moudle"><a href="#go-moudle" class="headerlink" title="go moudle"></a>go moudle</h3><p>在go1.11版本中引入了go moudle机制，它采用了一种全新的设计思想</p><p>通过go.mod文件实现</p><ol><li>准确地记录项目依赖</li><li>可重复构建</li></ol><p>核心是把项目及其依赖抽象成moudle</p><h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p>replace用于替换require中出现的包</p><p>它正常工作还需要满足两个条件：<br>第一，<code>replace</code>仅在当前module为<code>main module</code>时有效，比如我们当前在编译<code>github.com/renhongcai/gomodule</code>，此时就是<code>main module</code>，如果其他项目引用了<code>github.com/renhongcai/gomodule</code>，那么其他项目编译时，<code>replace</code>就会被自动忽略。</p><p>第二，<code>replace</code>指定中<code>=&gt;</code>前面的包及其版本号必须出现在<code>require</code>中才有效，否则指令无效，也会被忽略。 比如，上面的例子中，我们指定<code>replace github.com/google/uuid =&gt; github.com/google/uuid v1.1.0</code>，或者指定<code>replace github.com/google/uuid v1.0.9 =&gt; github.com/google/uuid v1.1.0</code>，二者均都无效。</p><h4 id="inderict"><a href="#inderict" class="headerlink" title="inderict"></a>inderict</h4><h4 id="go-get与go-install"><a href="#go-get与go-install" class="headerlink" title="go get与go install"></a>go get与go install</h4><p>go get 和 go install 是 Go 语言中的两个常用命令，它们用于获取和安装依赖包或将代码编译为可执行文件。它们的区别如下：</p><p>1、go get：</p><p>go get 用于获取、更新和安装远程依赖包。它会自动从远程代码库（如 GitHub、GitLab）下载依赖包，并将其安装到 GOPATH 或 GOMOD 目录中。</p><p>当您执行 go get 命令时，它会下载指定的包及其依赖项，并将其放置在正确的目录结构中，以供项目引用。</p><p>通常，go get 会自动安装依赖项，无需手动执行 go install。</p><p>2、go install：</p><p>go install 用于编译并安装 Go 语言的可执行程序。它将 Go 代码编译成二进制文件，并将其安装到 GOPATH 或 GOMOD 的 bin 目录中，以供后续执行。</p><p>当您执行 go install 命令时，它会在当前包的目录中执行编译过程，并将生成的可执行文件放置在 bin 目录中。</p><p>通过 go install 安装的可执行文件可以通过命令行直接运行，无需指定文件路径。</p><p>golang的1.16版本之后，go install可以在模块感知的模式下运行，可忽略当前目录或上层目录的 go.mod 文件。这对于在不影响主模块依赖的情况下（不会修改go.mod文件），安装二进制很方便；</p><ul><li>在将来，go install 被设计为“用于构建和安装二进制文件”， go get 则被设计为 “用于编辑 go.mod 变更依赖”，并且使用时，应该与 <code>-d</code> 参数共用，在将来版本中 <code>-d</code> 可能会默认启用；</li><li>非常的简单直观。需要注意的是 go install package@version是从 1.16 开始增加的，无论你当前是否在一个模块下，此命令都会在 <code>$GOPATH/bin</code> 下安装指定版本的工具。</li></ul><p>go get 将二进制安装相关的功能都转移到了 <code>go install</code>, 仅作为用于编辑 <code>go.mod</code> 文件的命令存在。在后续版本（计划是 Go 1.17）中删掉 <code>go get</code> 安装二进制的功能，接下来 <code>go get</code> 的行为就等同于我们现在执行 <code>go get -d</code> 命令了，仅需下载源码，并将依赖添加至 <code>go.mod</code> 即可。</p><p>在 Go 1.16 中，另一个行为变更是 <code>go build</code> 和 <code>go test</code> 不会自动编辑 <code>go.mod</code> 了，基于以上信息，Go 1.16 中将进行如下处理：</p><ul><li><p>通过在代码中修改 import 语句，来修改 <code>go.mod</code>：</p><ul><li><code>go get</code> 可用于添加新模块；</li><li><code>go mod tidy</code> 删除掉无用的模块；</li></ul></li><li><p>将未导入的模块写入 <code>go.mod</code>:</p><ul><li><code>go get &lt;package&gt;@&lt;version&gt;</code>;</li><li><code>go mod tidy</code> 也可以；</li><li>手动编辑；</li></ul></li></ul><h3 id="go-work"><a href="#go-work" class="headerlink" title="go work"></a>go work</h3><p>go work机制是1.18版本推出的，是go moudle的最后一块拼图</p><p>go work没出来之前的问题：</p><ul><li>当go.mod中引用的moudle未在github发布，那么go mod tidy时候会报错（多moudle开发的时候经常会遇到这个问题）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;总结一下go moudle相关内容&lt;/p&gt;
&lt;p&gt;golang的包管理经历了GOPATH、go vendor、go moudle三个阶段&lt;/p&gt;
&lt;h3 id=&quot;GOPATH机制&quot;&gt;&lt;a href=&quot;#GOPATH机制&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    <category term="golang" scheme="http://example.com/categories/golang/"/>
    
    
    <category term="golang" scheme="http://example.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>go包管理详解</title>
    <link href="http://example.com/2024/09/05/golang/go%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2024/09/05/golang/go%E5%8C%85%E7%AE%A1%E7%90%86/</id>
    <published>2024-09-05T01:46:45.408Z</published>
    <updated>2024-09-13T10:58:42.480Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下go moudle相关内容</p><h2 id="go-mod"><a href="#go-mod" class="headerlink" title="go mod"></a>go mod</h2><h3 id="go-get与go-install"><a href="#go-get与go-install" class="headerlink" title="go get与go install"></a>go get与go install</h3><p>go get 和 go install 是 Go 语言中的两个常用命令，它们用于获取和安装依赖包或将代码编译为可执行文件。它们的区别如下：</p><p>1、go get：</p><p>go get 用于获取、更新和安装远程依赖包。它会自动从远程代码库（如 GitHub、GitLab）下载依赖包，并将其安装到 GOPATH 或 GOMOD 目录中。</p><p>当您执行 go get 命令时，它会下载指定的包及其依赖项，并将其放置在正确的目录结构中，以供项目引用。</p><p>通常，go get 会自动安装依赖项，无需手动执行 go install。</p><p>2、go install：</p><p>go install 用于编译并安装 Go 语言的可执行程序。它将 Go 代码编译成二进制文件，并将其安装到 GOPATH 或 GOMOD 的 bin 目录中，以供后续执行。</p><p>当您执行 go install 命令时，它会在当前包的目录中执行编译过程，并将生成的可执行文件放置在 bin 目录中。</p><p>通过 go install 安装的可执行文件可以通过命令行直接运行，无需指定文件路径。</p><p>golang的1.16版本之后，go install可以在模块感知的模式下运行，可忽略当前目录或上层目录的 go.mod 文件。这对于在不影响主模块依赖的情况下（不会修改go.mod文件），安装二进制很方便；</p><ul><li>在将来，go install 被设计为“用于构建和安装二进制文件”， go get 则被设计为 “用于编辑 go.mod 变更依赖”，并且使用时，应该与 <code>-d</code> 参数共用，在将来版本中 <code>-d</code> 可能会默认启用；</li><li>非常的简单直观。需要注意的是 go install &lt;package@<version> 是从 1.16 开始增加的，无论你当前是否在一个模块下，此命令都会在 <code>$GOPATH/bin</code> 下安装指定版本的工具。</li></ul><p>go get 将二进制安装相关的功能都转移到了 <code>go install</code>, 仅作为用于编辑 <code>go.mod</code> 文件的命令存在。在后续版本（计划是 Go 1.17）中删掉 <code>go get</code> 安装二进制的功能，接下来 <code>go get</code> 的行为就等同于我们现在执行 <code>go get -d</code> 命令了，仅需下载源码，并将依赖添加至 <code>go.mod</code> 即可。</p><p>在 Go 1.16 中，另一个行为变更是 <code>go build</code> 和 <code>go test</code> 不会自动编辑 <code>go.mod</code> 了，基于以上信息，Go 1.16 中将进行如下处理：</p><ul><li><p>通过在代码中修改 import 语句，来修改 <code>go.mod</code>：</p><ul><li><code>go get</code> 可用于添加新模块；</li><li><code>go mod tidy</code> 删除掉无用的模块；</li></ul></li><li><p>将未导入的模块写入 <code>go.mod</code>:</p><ul><li><code>go get &lt;package&gt;[@&lt;version&gt;]</code>;</li><li><code>go mod tidy</code> 也可以；</li><li>手动编辑；</li></ul></li></ul><h3 id="go-work"><a href="#go-work" class="headerlink" title="go work"></a>go work</h3><p>go work机制是1.18版本推出的，是go moudle的最后一块拼图</p><p>go work没出来之前的问题：</p><ul><li>当go.mod中引用的moudle未在github发布，那么go mod tidy时候会报错（多moudle开发的时候经常会遇到这个问题）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;总结一下go moudle相关内容&lt;/p&gt;
&lt;h2 id=&quot;go-mod&quot;&gt;&lt;a href=&quot;#go-mod&quot; class=&quot;headerlink&quot; title=&quot;go mod&quot;&gt;&lt;/a&gt;go mod&lt;/h2&gt;&lt;h3 id=&quot;go-get与go-install&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="golang" scheme="http://example.com/categories/golang/"/>
    
    
    <category term="golang" scheme="http://example.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>goframe实践-2 ｜web开发</title>
    <link href="http://example.com/2024/08/25/goframe%E6%A1%86%E6%9E%B6/goframe%E5%AE%9E%E8%B7%B5-2%20%EF%BD%9Cweb%E5%BC%80%E5%8F%91/"/>
    <id>http://example.com/2024/08/25/goframe%E6%A1%86%E6%9E%B6/goframe%E5%AE%9E%E8%B7%B5-2%20%EF%BD%9Cweb%E5%BC%80%E5%8F%91/</id>
    <published>2024-08-25T09:17:40.002Z</published>
    <updated>2024-08-25T09:22:46.005Z</updated>
    
    
    
    
    <category term="goframe框架" scheme="http://example.com/categories/goframe%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>goframe实践-1｜架构与目录</title>
    <link href="http://example.com/2024/08/23/goframe%E6%A1%86%E6%9E%B6/goframe%E5%AE%9E%E8%B7%B5-1%EF%BD%9C%E6%9E%B6%E6%9E%84%E4%B8%8E%E7%9B%AE%E5%BD%95/"/>
    <id>http://example.com/2024/08/23/goframe%E6%A1%86%E6%9E%B6/goframe%E5%AE%9E%E8%B7%B5-1%EF%BD%9C%E6%9E%B6%E6%9E%84%E4%B8%8E%E7%9B%AE%E5%BD%95/</id>
    <published>2024-08-23T10:48:06.617Z</published>
    <updated>2024-09-09T02:28:51.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工程目录"><a href="#工程目录" class="headerlink" title="工程目录"></a>工程目录</h2><blockquote><p><a class="link"   href="https://goframe.org/pages/viewpage.action?pageId=30740166" >https://goframe.org/pages/viewpage.action?pageId=30740166<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>基本的工程目录结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">├── api</span><br><span class="line">├── hack</span><br><span class="line">├── internal</span><br><span class="line">│   ├── cmd</span><br><span class="line">│   ├── consts</span><br><span class="line">│   ├── controller</span><br><span class="line">│   ├── dao</span><br><span class="line">│   ├── logic</span><br><span class="line">│   ├── model</span><br><span class="line">│   |   ├── do</span><br><span class="line">│   │   └── entity</span><br><span class="line">│   └── service</span><br><span class="line">├── manifest</span><br><span class="line">├── resource</span><br><span class="line">├── utility</span><br><span class="line">├── go.mod</span><br><span class="line">└── main.go </span><br></pre></td></tr></table></figure><p>一个大体的目录结构如上，当然可以根据需要增减<br>goframe官方提供的一个示例项目focus-single目录如下：<br><img   src="https://raw.githubusercontent.com/miller-star/picture/master/20240909102833.png"  alt="image.png"></p><p>整体流程<br><img   src="https://goframe.org/download/attachments/30740166/image2022-6-22_16-2-37.png?version=1&modificationDate=1655884751621&api=v2" ></p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>这里着重讲一下model目录，数据结构管理模块，管理数据实体对象，以及输入与输出数据结构定义。<br><img   src="https://goframe.org/download/attachments/30740166/image2022-1-18_0-47-31.png?version=1&modificationDate=1642437918159&api=v2" ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;工程目录&quot;&gt;&lt;a href=&quot;#工程目录&quot; class=&quot;headerlink&quot; title=&quot;工程目录&quot;&gt;&lt;/a&gt;工程目录&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&quot;link&quot;   href=&quot;https://goframe.org/pages</summary>
      
    
    
    
    <category term="goframe框架" scheme="http://example.com/categories/goframe%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="goframe" scheme="http://example.com/tags/goframe/"/>
    
  </entry>
  
  <entry>
    <title>centos-python基础镜像构建</title>
    <link href="http://example.com/2024/07/18/%E9%9A%8F%E7%AC%94/centos-python%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA/"/>
    <id>http://example.com/2024/07/18/%E9%9A%8F%E7%AC%94/centos-python%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA/</id>
    <published>2024-07-18T11:32:22.000Z</published>
    <updated>2024-07-18T11:33:49.936Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a class="link"   href="https://www.cnblogs.com/leeona/p/18282312" >https://www.cnblogs.com/leeona/p/18282312<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>上述方案解决centos:7基础镜像无法pip的问题</p><blockquote><p><a class="link"   href="https://www.cnblogs.com/Jimc/p/10218387.html" >https://www.cnblogs.com/Jimc/p/10218387.html<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://www.cnblogs.com/Jimc/p/10218062.html" >https://www.cnblogs.com/Jimc/p/10218062.html<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>源码编译安装python3.8</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&quot;link&quot;   href=&quot;https://www.cnblogs.com/leeona/p/18282312&quot; &gt;https://www.cnblogs.com/leeona/p/18282312&lt;i class=&quot;fas f</summary>
      
    
    
    
    
    <category term="运维" scheme="http://example.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>centos9安装mysql服务端记录</title>
    <link href="http://example.com/2024/07/18/%E9%9A%8F%E7%AC%94/centos9%E5%AE%89%E8%A3%85mysql%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2024/07/18/%E9%9A%8F%E7%AC%94/centos9%E5%AE%89%E8%A3%85mysql%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AE%B0%E5%BD%95/</id>
    <published>2024-07-18T09:01:57.000Z</published>
    <updated>2024-07-18T09:04:44.341Z</updated>
    
    <content type="html"><![CDATA[<p>安装的主要流程：<a class="link"   href="https://www.sjkjc.com/posts/install-mysql8-on-centos-stream-9/" >https://www.sjkjc.com/posts/install-mysql8-on-centos-stream-9/<i class="fas fa-external-link-alt"></i></a></p><p>之后，远程登录的时候，会报错：</p><p>mysql -h ‘安装mysql服务端机器的IP’ -u root</p><p>ERROR 1130 (HY000): Host ‘客户端的IP’ is not allowed to connect to this MySQL server这个错误什么原因导致的。</p><p>这通常是由于 MySQL 的权限设置导致的。</p><p>MySQL 的权限系统允许数据库管理员指定哪些用户可以从哪些主机连接到服务器。在这个案例中，尽管你使用了 <code>root</code> 用户，但可能 <code>root</code> 用户没有从 <code>客户端IP</code> 这个 IP 地址连接到服务器的权限。</p><p>在 MySQL 中，<code>GRANT</code> 语句用于分配权限，但是 <code>IDENTIFIED BY</code> 子句用于创建用户或更改用户密码，并不应该在 <code>GRANT</code> 语句中使用。因此，你遇到的错误是因为语法不正确。</p><p>你应该首先确保用户 <code>root</code>@<code>客户端IP</code> 存在，如果不存在，你需要先创建这个用户，然后再分配权限。以下是正确的步骤：</p><ol><li><p>创建用户（如果尚不存在）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;root&#x27;@&#x27;客户端IP&#x27; IDENTIFIED BY &#x27;WingKin45@&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>分配权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;客户端IP&#x27; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure></li><li><p>使权限更改生效</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p>按照这些步骤操作后，<code>root</code> 用户应该能够从 IP 地址 <code>客户端IP</code> 连接到 MySQL 服务器，并拥有所有数据库和表的权限。如果你仍然遇到问题，请检查 MySQL 服务器的配置文件（如 <code>my.cnf</code> 或 <code>my.ini</code>），确保没有限制远程连接的设置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;安装的主要流程：&lt;a class=&quot;link&quot;   href=&quot;https://www.sjkjc.com/posts/install-mysql8-on-centos-stream-9/&quot; &gt;https://www.sjkjc.com/posts/install-mysq</summary>
      
    
    
    
    
    <category term="运维" scheme="http://example.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>docker命令</title>
    <link href="http://example.com/2024/07/18/%E9%9A%8F%E7%AC%94/docker%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2024/07/18/%E9%9A%8F%E7%AC%94/docker%E5%91%BD%E4%BB%A4/</id>
    <published>2024-07-18T07:59:02.000Z</published>
    <updated>2024-07-20T10:32:49.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker-常用命令"><a href="#docker-常用命令" class="headerlink" title="docker 常用命令"></a>docker 常用命令</h2><blockquote><p><a class="link"   href="https://yeasy.gitbook.io/docker_practice/image/commit" >https://yeasy.gitbook.io/docker_practice/image/commit<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>1.docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker commit \</span><br><span class="line">    --author &quot;Tao Wang &lt;twang2218@gmail.com&gt;&quot; \</span><br><span class="line">    --message &quot;修改了默认网页&quot; \</span><br><span class="line">    webserver \</span><br><span class="line">    nginx:v2</span><br><span class="line">sha256:07e33465974800ce65751acc279adc6ed2dc5ed4e0838f8b86f0c87aa1795214</span><br></pre></td></tr></table></figure><ol start="2"><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker-常用命令&quot;&gt;&lt;a href=&quot;#docker-常用命令&quot; class=&quot;headerlink&quot; title=&quot;docker 常用命令&quot;&gt;&lt;/a&gt;docker 常用命令&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&quot;link&quot;   hre</summary>
      
    
    
    
    
    <category term="docker" scheme="http://example.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://example.com/2024/07/16/%E9%9A%8F%E7%AC%94/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2024/07/16/%E9%9A%8F%E7%AC%94/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-07-16T12:04:28.000Z</published>
    <updated>2024-07-16T12:14:58.315Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a class="link"   href="https://blog.csdn.net/justloveyou_/article/details/64127789" >https://blog.csdn.net/justloveyou_/article/details/64127789<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>golang的单例模式：</p><blockquote><p><a class="link"   href="https://blog.csdn.net/qq_43035350/article/details/125536474" >https://blog.csdn.net/qq_43035350/article/details/125536474<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&quot;link&quot;   href=&quot;https://blog.csdn.net/justloveyou_/article/details/64127789&quot; &gt;https://blog.csdn.net/justloveyou_/art</summary>
      
    
    
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
